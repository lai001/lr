use crate::misc::function_meta_token_stream;
use crate::misc::impl_struct_meta_container;
use crate::misc::param_meta_token_stream;
use crate::misc::struct_field_meta_token_stream;
use crate::misc::{struct_reflection, struct_reflection_new};
use anyhow::anyhow;
use ast::HasModuleItem;
use proc_macro2::TokenStream;
use ra_ap_hir::GenericDef;
use ra_ap_hir::HasVisibility;
use ra_ap_hir::HirDisplay;
use ra_ap_ide::*;
use ra_ap_ide_db::*;
use ra_ap_load_cargo::*;
use ra_ap_proc_macro_api::ProcMacroClient;
use ra_ap_project_model::*;
use ra_ap_syntax::*;
use ra_ap_vfs::*;
use std::{cell::RefCell, rc::Rc};

pub struct ParseResult {
    pub rs_struct: ra_ap_hir::Struct,
    pub impl_defs: Vec<ra_ap_hir::Impl>,
    pub db: Rc<RootDatabase>,
    pub vfs: Rc<RefCell<Vfs>>,
}

impl ParseResult {
    pub fn generate_reflection_token_stream(&self) -> anyhow::Result<TokenStream> {
        let db = self.db.as_ref();
        // let sema = Semantics::new(db);
        let struct_name = self.rs_struct.name(db).as_str().to_string();
        let mut token_stream = quote::quote! {
            //! THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
            #![allow(warnings)]
            use rs_reflection_core::*;
        };

        token_stream.extend(struct_reflection(&struct_name));

        let mut fields_token_stream = quote::quote! {};
        let mut functions_token_stream = quote::quote! {};
        for field in self.rs_struct.fields(db) {
            let name = field.name(db).as_str().to_string();
            let ty = field.ty(db);
            let module = self.rs_struct.module(db);
            //sema.scope(pat.syntax())?.module();
            let inferred_type = ty
                .display_source_code(db, module.into(), false)
                .map_err(|err| anyhow!("{:?}", err))?;

            fields_token_stream.extend(struct_field_meta_token_stream(&name, &inferred_type));
        }

        for impl_def in self.impl_defs.clone() {
            for assoc_item in impl_def.items(db) {
                match assoc_item {
                    ra_ap_hir::AssocItem::Function(function) => {
                        let fn_name = function.name(db).as_str().to_string();
                        let return_ty = function.ret_type(db);
                        let module = self.rs_struct.module(db);
                        let inferred_return_type = return_ty
                            .display_source_code(db, module.into(), false)
                            .map_err(|err| anyhow!("{:?}", err))?;

                        let mut params_token_stream = quote::quote! {};

                        let params = if let Some(_) = function.self_param(db) {
                            function.params_without_self(db)
                        } else if let Some(params) = function.method_params(db) {
                            params
                        } else {
                            function.assoc_fn_params(db)
                        };
                        for param in params {
                            let name = param.name(db).map(|x| x.as_str().to_string());
                            let ty = param.ty();
                            let module = self.rs_struct.module(db);
                            let inferred_type = ty
                                .display_source_code(db, module.into(), false)
                                .map_err(|err| anyhow!("{:?}", err))?;
                            params_token_stream
                                .extend(param_meta_token_stream(name.as_deref(), &inferred_type));
                        }

                        functions_token_stream.extend(function_meta_token_stream(
                            &fn_name,
                            &inferred_return_type,
                            params_token_stream,
                        ));
                    }
                    _ => {}
                }
            }
        }

        token_stream.extend(struct_reflection_new(
            &struct_name,
            fields_token_stream,
            functions_token_stream,
        ));

        let mut exec_without_self_token_stream = proc_macro2::TokenStream::default();
        let mut exec_with_mut_self_token_stream = proc_macro2::TokenStream::default();
        let mut exec_with_self_token_stream = proc_macro2::TokenStream::default();

        for impl_def in self.impl_defs.clone() {
            for assoc_item in impl_def.items(db) {
                match assoc_item {
                    ra_ap_hir::AssocItem::Function(function) => {
                        if !Self::is_supported_function(db, &function) {
                            continue;
                        }
                        let fn_name = function.name(db).as_str().to_string();
                        let return_type = function.ret_type(db);
                        let module = self.rs_struct.module(db);
                        // let inferred_return_type = return_type
                        //     .display_source_code(db, module.into(), false)
                        //     .map_err(|err| anyhow!("{:?}", err))?;
                        let is_unit = return_type.is_unit();

                        let fn_name_token: TokenStream =
                            fn_name.parse().map_err(|err| anyhow!("{err}"))?;
                        let struct_name_token: TokenStream =
                            struct_name.parse().map_err(|err| anyhow!("{err}"))?;
                        // let struct_type_name_token: TokenStream = format!("{}Type", struct_name)
                        //     .parse()
                        //     .map_err(|err| anyhow!("{err}"))?;
                        // let return_type_token: TokenStream = inferred_return_type
                        //     .parse()
                        //     .map_err(|err| anyhow!("{err}"))?;

                        // {
                        //     log::trace!("{}", fn_name);
                        // }

                        if let Some(self_param) = function.self_param(db) {
                            let params = function.params_without_self(db);
                            let is_mut_self = self_param.ty(db).is_mutable_reference();
                            let params_len_token_stream: TokenStream = (params.len() as isize - 1)
                                .to_string()
                                .parse()
                                .map_err(|err| anyhow!("{err}"))?;

                            let package_parameters_token_stream;

                            let parameter_list_token_stream =
                                Self::parameter_list_token_stream(db, module, &params)?;
                            let call_parameters_list_token_stream =
                                Self::call_parameters_list_token_stream(db, &params)?;

                            let check_len = if params.is_empty() {
                                quote::quote! {}
                            } else {
                                quote::quote! {
                                    if params.len() <= #params_len_token_stream {
                                        return None;
                                    }
                                }
                            };

                            if is_unit {
                                package_parameters_token_stream = quote::quote! {
                                    #check_len
                                    #parameter_list_token_stream
                                    self_param.#fn_name_token(#call_parameters_list_token_stream);
                                };
                            } else {
                                package_parameters_token_stream = quote::quote! {
                                    #check_len
                                    #parameter_list_token_stream
                                    return Some(Box::new(self_param.#fn_name_token(#call_parameters_list_token_stream)));
                                };
                            }

                            let downcast_type_stream = if is_mut_self {
                                quote::quote! {
                                    downcast_mut
                                }
                            } else {
                                quote::quote! {
                                    downcast_ref
                                }
                            };
                            let template = quote::quote! {
                                #fn_name => {
                                    if let Some(self_param) = self_param.#downcast_type_stream::<#struct_name_token>() {
                                        #package_parameters_token_stream
                                    }
                                    return None;
                                }
                            };

                            if is_mut_self {
                                exec_with_mut_self_token_stream.extend(template);
                            } else {
                                exec_with_self_token_stream.extend(template);
                            }
                        } else {
                            let params = function.assoc_fn_params(db);

                            let params_len_token_stream: TokenStream = (params.len() as isize - 1)
                                .to_string()
                                .parse()
                                .map_err(|err| anyhow!("{err}"))?;

                            let package_parameters_token_stream;

                            let parameter_list_token_stream =
                                Self::parameter_list_token_stream(db, module, &params)?;
                            let call_parameters_list_token_stream =
                                Self::call_parameters_list_token_stream(db, &params)?;

                            let check_len = if params.is_empty() {
                                quote::quote! {}
                            } else {
                                quote::quote! {
                                    if params.len() <= #params_len_token_stream {
                                        return None;
                                    }
                                }
                            };

                            if is_unit {
                                package_parameters_token_stream = quote::quote! {
                                    #check_len
                                    #parameter_list_token_stream
                                    #struct_name_token::#fn_name_token(#call_parameters_list_token_stream);
                                };
                            } else {
                                package_parameters_token_stream = quote::quote! {
                                    #check_len
                                    #parameter_list_token_stream
                                    return Some(Box::new(#struct_name_token::#fn_name_token(#call_parameters_list_token_stream)));
                                };
                            }

                            let template = quote::quote! {
                                #fn_name => {
                                    #package_parameters_token_stream
                                }
                            };

                            exec_without_self_token_stream.extend(template);
                        }
                    }
                    _ => {}
                }
            }
        }

        token_stream.extend(impl_struct_meta_container(
            &struct_name,
            exec_without_self_token_stream,
            exec_with_mut_self_token_stream,
            exec_with_self_token_stream,
        ));

        Ok(token_stream.into())
    }

    fn is_supported_type(db: &RootDatabase, ty: ra_ap_hir::Type) -> bool {
        (ty.type_and_const_arguments(db, Edition::CURRENT).count() > 0
            || ty.is_closure()
            || ty.is_fn()
            || ty.as_callable(db).is_some()
            || ty.is_never()
            || ty.as_dyn_trait().is_some()
            || ty.is_unknown()
            || ty.impls_fnonce(db))
            || ty.as_impl_traits(db).is_some() == false
    }

    fn is_supported_function(db: &RootDatabase, function: &ra_ap_hir::Function) -> bool {
        let generics = GenericDef::from(*function);

        if let Some(type_params) = generics
            .type_or_const_params(db)
            .into_iter()
            .map(|it| it.as_type_param(db))
            .collect::<Option<Vec<ra_ap_hir::TypeParam>>>()
        {
            if !type_params.is_empty() {
                return false;
            }
        }

        if !Self::is_supported_type(db, function.ty(db)) {
            return false;
        }
        let fn_name = function.name(db).as_str().to_string();
        let return_type = function.ret_type(db);
        if !Self::is_supported_type(db, return_type) {
            return false;
        }
        if fn_name == "Drop" {
            return false;
        }
        if function.visibility(db) != ra_ap_hir::Visibility::Public {
            return false;
        }
        let params = if let Some(_) = function.self_param(db) {
            function.params_without_self(db)
        } else {
            function.assoc_fn_params(db)
        };
        for param in params {
            let ty = param.ty();
            if !Self::is_supported_type(db, ty.clone()) {
                return false;
            }
        }
        true
    }

    fn call_parameters_list_token_stream(
        db: &RootDatabase,
        params: &[ra_ap_hir::Param],
    ) -> anyhow::Result<TokenStream> {
        let mut call_parameters_list_token_stream = TokenStream::default();
        for (rev_index, param) in params.iter().enumerate() {
            let param_name = param
                .name(db)
                .map(|x| x.as_str().to_string())
                .unwrap_or(format!("v{}", rev_index));
            let param_name_stream: TokenStream =
                param_name.parse().map_err(|err| anyhow!("{err}"))?;
            call_parameters_list_token_stream.extend(quote::quote! {
                #param_name_stream,
            });
        }
        Ok(call_parameters_list_token_stream)
    }

    fn parameter_list_token_stream(
        db: &RootDatabase,
        module: ra_ap_hir::Module,
        params: &[ra_ap_hir::Param],
    ) -> anyhow::Result<TokenStream> {
        let mut parameter_list_token_stream = TokenStream::default();
        for (rev_index, param) in params.iter().enumerate().rev() {
            let param_type_prefix_token_stream = if param.ty().contains_reference(db) {
                if param.ty().is_mutable_reference() {
                    quote::quote! {
                        *mut
                    }
                } else {
                    quote::quote! {
                        *const
                    }
                }
            } else {
                quote::quote! {}
            };

            let inferred_param_type = param
                .ty()
                .strip_reference()
                .display_source_code(db, module.into(), false)
                .map_err(|err| anyhow!("{:?}", err))?;
            let inferred_param_type_token_stream: TokenStream = inferred_param_type
                .parse()
                .map_err(|err| anyhow!("{:?}", err))?;

            let param_name = param
                .name(db)
                .map(|x| x.as_str().to_string())
                .unwrap_or(format!("v{}", rev_index));
            let rev_index_stream: TokenStream = rev_index
                .to_string()
                .parse()
                .map_err(|err| anyhow!("{err}"))?;
            let param_name_stream: TokenStream =
                param_name.parse().map_err(|err| anyhow!("{err}"))?;

            let ext_token_stream = if param.ty().contains_reference(db) {
                if param.ty().is_mutable_reference() {
                    quote::quote! {
                        let #param_name_stream = unsafe {
                            (*(params.remove(#rev_index_stream).downcast::<#param_type_prefix_token_stream #inferred_param_type_token_stream>().ok()?)).as_mut()
                        }?;
                    }
                } else {
                    quote::quote! {
                        let #param_name_stream = unsafe {
                            (*(params.remove(#rev_index_stream).downcast::<#param_type_prefix_token_stream #inferred_param_type_token_stream>().ok()?)).as_ref()
                        }?;
                    }
                }
            } else {
                quote::quote! {
                    let #param_name_stream = *params.remove(#rev_index_stream).downcast::<#inferred_param_type_token_stream>().ok()?;
                }
            };
            parameter_list_token_stream.extend(quote::quote! {
                #ext_token_stream
            });
        }
        Ok(parameter_list_token_stream)
    }
}

pub struct ReflectionContext {
    _manifest_file_path: AbsPathBuf,
    _project_manifest: ProjectManifest,
    _cargo_config: CargoConfig,
    _project_workspace: ProjectWorkspace,
    db: Rc<RootDatabase>,
    vfs: Rc<RefCell<Vfs>>,
    _proc_macro: Option<ProcMacroClient>,
}

impl ReflectionContext {
    pub fn new(manifest_file_path: AbsPathBuf) -> anyhow::Result<Self> {
        let mut cargo_config = CargoConfig::default();
        cargo_config.sysroot = Some(RustLibSource::Discover);
        let project_manifest = ProjectManifest::from_manifest_file(manifest_file_path.clone())?;
        let project_workspace = ProjectWorkspace::load(
            project_manifest.clone(),
            &cargo_config,
            &load_project_workspace_progress,
        )?;
        let load_cargo_config: LoadCargoConfig = LoadCargoConfig {
            load_out_dirs_from_check: true,
            with_proc_macro_server: ProcMacroServerChoice::None,
            prefill_caches: false,
        };
        let (db, vfs, proc_macro) = load_workspace(
            project_workspace.clone(),
            &cargo_config.extra_env,
            &load_cargo_config,
        )?;

        Ok(Self {
            _manifest_file_path: manifest_file_path,
            _project_manifest: project_manifest,
            _cargo_config: cargo_config,
            _project_workspace: project_workspace,
            db: Rc::new(db),
            vfs: Rc::new(RefCell::new(vfs)),
            _proc_macro: proc_macro,
        })
    }

    pub fn parse_file(&mut self, file_path: AbsPathBuf) -> anyhow::Result<ParseResult> {
        let path = VfsPath::new_real_path(file_path.as_str().to_string());
        let source_file_id = self
            .vfs
            .borrow()
            .file_id(&path)
            .ok_or(anyhow!("No source file found"))?
            .0;
        let editioned_file_id: EditionedFileId = EditionedFileId::current_edition(source_file_id);
        // let file_item_tree = self.db.file_item_tree(editioned_file_id.into());
        // for top_level_item in file_item_tree.top_level_items() {
        //     log::trace!("top_level_item: {:?}", top_level_item);
        // }
        let sema: Semantics<'_, ra_ap_ide::RootDatabase> = Semantics::new(&self.db);

        let source_file: SourceFile = sema.parse(editioned_file_id);

        // let node_or_tokens = source_file.syntax().descendants_with_tokens();
        // for node_or_token in node_or_tokens {
        //     if let Some(token) = node_or_token.as_token() {
        //         log::trace!("token: {:?}, {}", token.text_range(), token.text());
        //     } else if let Some(node) = node_or_token.as_node() {
        //         let _ = node;
        //         // log::trace!("node: {}", node);
        //     } else {
        //         log::warn!("Not a token or node");
        //     }
        // }
        let db = self.db.as_ref();
        let mut find_rs_struct: Option<ra_ap_hir::Struct> = None;
        let mut find_rs_struct_impls: Vec<ra_ap_hir::Impl> = vec![];

        for item in source_file.items() {
            // match &item {
            //     ast::Item::Const(_) => {log::trace!("Const: {item}")},
            //     ast::Item::Enum(_) => {log::trace!("Enum: {item}")},
            //     ast::Item::ExternBlock(extern_block) => {log::trace!("ExternBlock: {item}")},
            //     ast::Item::ExternCrate(extern_crate) => {log::trace!("ExternCrate: {item}")},
            //     ast::Item::Fn(_) => {log::trace!("Fn: {item}")},
            //     ast::Item::Impl(_) => {log::trace!("Impl: {item}")},
            //     ast::Item::MacroCall(macro_call) => {log::trace!("MacroCall: {item}")},
            //     ast::Item::MacroDef(macro_def) => {log::trace!("MacroDef: {item}")},
            //     ast::Item::MacroRules(macro_rules) => {log::trace!("MacroRules: {item}")},
            //     ast::Item::Module(module) => {log::trace!("Module: {item}")},
            //     ast::Item::Static(_) => {log::trace!("Static: {item}")},
            //     ast::Item::Struct(_) => {log::trace!("Struct: {item}")},
            //     ast::Item::Trait(_) => {log::trace!("Trait: {item}")},
            //     ast::Item::TraitAlias(trait_alias) => {log::trace!("TraitAlias: {item}")},
            //     ast::Item::TypeAlias(type_alias) => {log::trace!("TypeAlias: {item}")},
            //     ast::Item::Union(union) => {log::trace!("Union: {item}")},
            //     ast::Item::Use(_) => {log::trace!("Use: {item}")},
            // }
            match item {
                ast::Item::Impl(impl_item) => {
                    let impl_def = sema.to_impl_def(&impl_item).ok_or(anyhow!("Unknow"))?;
                    find_rs_struct_impls.push(impl_def);
                }
                ast::Item::Struct(rs_struct) => {
                    let rs_struct = sema.to_struct_def(&rs_struct).ok_or(anyhow!("Unknow"))?;
                    find_rs_struct = Some(rs_struct);
                }
                _ => {}
            }
        }

        if let Some(rs_struct) = find_rs_struct {
            let find_rs_struct_impls = find_rs_struct_impls
                .iter()
                .filter(|x| rs_struct.ty(db) == x.self_ty(db))
                .cloned()
                .collect();
            return Ok(ParseResult {
                rs_struct,
                impl_defs: find_rs_struct_impls,
                db: self.db.clone(),
                vfs: self.vfs.clone(),
            });
        }

        return Err(anyhow!("Can not found struct"));
    }

    pub fn dump_all_files(&self) {
        for (file_id, path) in self.vfs.borrow().iter() {
            log::trace!("{:?}, {}", file_id, path);
        }
    }
}

fn load_project_workspace_progress(message: String) -> () {
    let _ = message;
}
